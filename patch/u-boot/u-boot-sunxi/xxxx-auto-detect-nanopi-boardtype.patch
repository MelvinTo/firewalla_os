From 69d0aff40a39a04b2a3a2a2249e39da75a51b0c0 Mon Sep 17 00:00:00 2001
From: wuweidong <625769020@qq.com>
Date: Sat, 12 Oct 2019 17:39:06 +0800
Subject: [PATCH] able to auto detect nanopi boardtype

---
 board/sunxi/board.c                 | 311 ++++++++++++++++++++++++++++
 configs/nanopi_neo2_black_defconfig |  20 +-
 include/friendlyelec/boardtype.h    |  61 ++++++
 3 files changed, 385 insertions(+), 7 deletions(-)
 create mode 100644 include/friendlyelec/boardtype.h

diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index a3ee6edb..3b2774a3 100644
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -725,7 +725,303 @@ static void setup_environment(const void *fdt)
 	}
 }
 
+#include <friendlyelec/boardtype.h>
+#if defined(CONFIG_MACH_SUN8I_H3_NANOPI)
+char nanopi_board[][BOARD_NAME_LENGTH] = {
+    "nanopi-m1",
+    "nanopi-neo",
+    "nanopi-neo-air",
+    "nanopi-m1-plus",
+    "nanopi-duo",
+    "nanopi-neo-core",
+    "nanopi-k1",
+    "nanopi-hero",
+    "nanopi-duo2",
+    "nanopi-r1",
+    "nanopi-neo-s",
+    "zeropi",
+    "nanopi-r1s",
+};
+#if 0
+int nanopi_dram_clk[] = {
+    576 /* NanoPi-M1 */,
+    408 /* NanoPi-NEO */,
+    408 /* NanoPi-NEO-Air */,
+    576 /* NanoPi-M1-Plus */,
+    408 /* NanoPi-Duo */,
+    408 /* NanoPi-NEO-Core */,
+    576 /* NanoPi-K1 */,
+    408 /* NanoPi-Hero */,
+};
+#endif
+#elif defined(CONFIG_MACH_SUN50I_H5_NANOPI)
+char nanopi_board[][BOARD_NAME_LENGTH] = {
+    "nanopi-neo-core2",
+    "nanopi-neo2",
+    "nanopi-neo-plus2",
+    "nanopi-m1-plus2",
+    "nanopi-k1-plus",
+    "nanopi-neo2-v1.1",
+    "nanopi-neo2-black",
+    "nanopi-r1s",
+};
+#if 0
+int nanopi_dram_clk[] = {
+    504 /* NanoPi-NEO-Core2 */,
+    504 /* NanoPi-NEO2 */,
+    504 /* NanoPi-NEO-Plus2 */,
+    504 /* NanoPi-M1-Plus2 */,
+    504 /* NanoPi-K1-Plus */,
+};
+#endif
+#endif
+
 #if defined(CONFIG_BOOT_PROCESS_MULTI_DTB) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_MACH_SUN8I_H3_NANOPI) || defined(CONFIG_MACH_SUN50I_H5_NANOPI)
+#include <asm/arch/gpio.h>
+#include <asm/gpio.h>
+int nanopi_read_gpio(void)
+{
+	int ret = -1, gpio = 0;
+	char pin_label[16];
+	char pin[2][8] = {
+		"PC4",
+		"PC7",
+	};	
+	int i, pin_num, id_pin, pin_value;
+	
+	pin_num = sizeof(pin) / sizeof(pin[0]);
+	for (i=0; i<pin_num; i++) {
+		memset(pin_label, 0, sizeof(pin_label));
+		sprintf(pin_label, "boardid_%d", i);
+		id_pin = sunxi_name_to_gpio(pin[i]);
+		ret = gpio_request(id_pin, pin_label);
+		if (!ret) {
+			gpio_direction_input(id_pin);
+			pin_value = gpio_get_value(id_pin);
+			gpio |= pin_value<<i;
+			gpio_free(id_pin);
+		} else {
+			printf("fail to request gpio %d\n", id_pin);
+			hang(); 
+		}
+	}
+	return gpio;
+}
+
+int nanopi_read_extra_gpio(char pin_name[][8], int num, int pull)
+{
+	int ret = -1, gpio = 0;
+	char pin_label[16];
+	char pin[8][8];
+	int i, id_pin, pin_value, old_func;
+
+	for (i=0; i<num; i++) {
+		memset(pin_label, 0, sizeof(pin_label));
+		sprintf(pin_label, "boardid_%d", i);
+		strcpy(pin[i], pin_name[i]);
+		id_pin = sunxi_name_to_gpio(pin[i]);
+		ret = gpio_request(id_pin, pin_label);
+		if (!ret) {
+			old_func = sunxi_gpio_get_cfgpin(id_pin);	// store func
+			gpio_direction_input(id_pin);
+			sunxi_gpio_set_pull(id_pin, pull);
+			mdelay(2);
+			pin_value = gpio_get_value(id_pin);
+			gpio |= pin_value<<i;
+			sunxi_gpio_set_cfgpin(id_pin, old_func);    // resotre func
+			gpio_free(id_pin);
+		} else {
+			printf("fail to request gpio %d\n", id_pin);
+			hang(); 
+		}
+	}
+	return gpio;
+}
+
+int nanopi_get_board(void)
+{
+	int ret = -1, boardtype = -1, cputype = -1;
+	unsigned int sid[4];
+	int extra_gpio;
+	char pin[8][8];
+	
+	ret = sunxi_get_sid(sid);
+	if (ret == 0 && sid[0] != 0) {
+		cputype = sid[0] & 0xff;
+	}
+	switch (cputype) {
+	case CPU_TYPE_H2_1:
+	case CPU_TYPE_H2_2:
+		boardtype = BOARD_TYPE_NANOPI_DUO;
+		env_set("cpu", "h2-plus");
+		break;
+	case CPU_TYPE_H5:			// don't really rely on this(H5-CPUID=0x01?)
+		boardtype = nanopi_read_gpio();
+		env_set("cpu", "h5");	// nowhere is using env-cpu=h5, so it doesn't matter.
+
+		/*
+		 * variant 0
+		 * 1. nanopi-neo-core2, PC6=1
+		 * 1. nanopi-r1s, PC6=0
+		 */
+		if (boardtype == BOARD_TYPE_H5_VARIANT0) {
+			strcpy(pin[0], "PC6");
+			extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DISABLE);
+			boardtype = (extra_gpio == 0 ? BOARD_TYPE_NANOPI_R1S_H5 : BOARD_TYPE_NANOPI_NEO_CORE2);
+			break;
+		}
+
+		/*
+		 * variant 1
+		 * 1. nanopi-neo2,  PL3=1
+		 * 2. nanopi-neo2-v1.1,  PL3=0, PE4=0
+		 * 3. nanopi-neo2-black, PL3=0, PE4=1
+		 */
+		if (boardtype == BOARD_TYPE_H5_VARIANT1) {
+			strcpy(pin[0], "PL3");
+			extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DISABLE);
+			if (extra_gpio == 0) {
+				strcpy(pin[0], "PE4");
+				extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DISABLE);
+				boardtype = (extra_gpio == 0 ? BOARD_TYPE_NANOPI_NEO2_V11 : BOARD_TYPE_NANOPI_NEO2_BLACK);
+			} else {
+				boardtype = BOARD_TYPE_NANOPI_NEO2;
+			}
+			break;
+		}
+
+		/*
+		 * variant 2
+		 * 1. nanopi-neo-plus2
+		 */
+		if (boardtype == BOARD_TYPE_H5_VARIANT2) {
+			boardtype = BOARD_TYPE_NANOPI_NEO_PLUS2;
+			break;
+		}
+
+		/*
+		 * variant 3
+		 * 1. nanopi-m1-plus2,  PL5=0,
+		 * 2. nanopi-k1-plus,  PL5=1
+		 */
+		// nanopi-m1-plus2 or nanopi-k1-plus
+		if (boardtype == BOARD_TYPE_H5_VARIANT3) {
+			strcpy(pin[0], "PL5");
+			extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DISABLE);
+			boardtype = (extra_gpio == 0 ? BOARD_TYPE_NANOPI_M1_PLUS2 : BOARD_TYPE_NANOPI_K1_PLUS);
+			break;
+		}
+
+		break;
+	default:					// dafault is H3.boot.src will use env-cpu=h3
+		boardtype = nanopi_read_gpio();
+		env_set("cpu", "h3");
+
+		/*
+		 * variant 0
+		 * 1. nanopi-m1,  PL5=0,
+		 * 2. nanopi-r1,  PL5=1, PC6=1
+		 * 3. nanopi-r1s, PL5=1, PC6=0
+		 */
+		if (boardtype == BOARD_TYPE_H3_VARIANT0) {
+			// 1) nanopi-r1 / nanopi-r1s's PL5 = 1
+			// 2) nanopi-m1's PL5 = 0
+			strcpy(pin[0], "PL5");
+			extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DISABLE);
+			if (extra_gpio == 1) {
+				strcpy(pin[0], "PC6");
+				extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DISABLE);
+				if (extra_gpio == 1) {
+					boardtype = BOARD_TYPE_NANOPI_R1;
+				} else {
+					boardtype = BOARD_TYPE_NANOPI_R1S_H3;
+				}
+				break;
+			} else {
+				boardtype = BOARD_TYPE_NANOPI_M1;
+				break;
+			}
+
+			// nanopi-m1
+			break;
+		}
+
+		/*
+		 * variant 1
+		 * 1. nanopi-neo,      PC6=PDN, PD6=?, PE7=0
+		 * 2. nanopi-neo-core, PC6=1,   PD6=1, PE7=?
+		 * 3. nanopi-duo2,     PC6=1,   PD6=0, PE7=?
+		 * 4. zeropi,          PC6=0,   PD6=?, PE7=1
+		 */
+		if (boardtype == BOARD_TYPE_H3_VARIANT1) {
+			/* nanopi-neo's PC6 is NC. So pull it down by software*/
+			strcpy(pin[0], "PC6");
+			extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DOWN);
+			if (extra_gpio == 1) {
+				strcpy(pin[0], "PD6");
+				/* NanoPi-NEO-Core's PD6  is NC. So pull it up by software*/
+				extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_UP);
+				if (extra_gpio == 0) {
+					boardtype = BOARD_TYPE_NANOPI_DUO2;
+				} else {
+					boardtype = BOARD_TYPE_NANOPI_NEO_CORE;
+				}
+				break;
+			} else {
+				strcpy(pin[0], "PE7");
+				extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DOWN);
+				if (extra_gpio == 1) {
+					boardtype = BOARD_TYPE_ZEROPI;
+				} else {
+					boardtype = BOARD_TYPE_NANOPI_NEO;
+				}
+				break;
+			}
+			// nanopi-neo
+			break;
+		}
+
+		/*
+		 * variant 2
+		 * 1. nanopi-neo-air
+		 */
+		if (boardtype == BOARD_TYPE_H3_VARIANT2) {
+			boardtype = BOARD_TYPE_NANOPI_NEO_AIR;
+			break;
+		}
+
+		/*
+		 * variant 3
+		 * 1. nanopi-m1-plus, PC6=1
+		 * 2. nanopi-neo-s,   PC6=0
+		 */
+		if (boardtype == BOARD_TYPE_H3_VARIANT3) {
+
+			strcpy(pin[0], "PC6");
+			extra_gpio = nanopi_read_extra_gpio(pin, 1, SUNXI_GPIO_PULL_DISABLE);
+			if (extra_gpio == 0) {
+				boardtype = BOARD_TYPE_NANOPI_NEO_S;
+			} else {
+				boardtype = BOARD_TYPE_NANOPI_M1_PLUS;
+			}
+			// nanopi-m1-plus
+			break;
+		}
+
+		break;
+	}
+	if (boardtype>=0 && boardtype<BOARD_TYPE_MAX) {
+		return boardtype;
+	} else {
+		printf("UNKNOWN BOARDTYPE: boardtype=%d cputype=%d\n", boardtype, cputype);
+		hang();
+	}
+	return boardtype;
+}
+#endif
+
+
 
 #define NP_NEO2_DT_SS			"nanopi-neo2."
 
@@ -790,6 +1086,21 @@ void boot_process_multi_dtb(void)
 			}
 		}
 	}
+#if defined(CONFIG_MACH_SUN8I_H3_NANOPI) || defined(CONFIG_MACH_SUN50I_H5_NANOPI)
+	int npi_boardtype = -1;
+	char buf[128];
+	npi_boardtype = nanopi_get_board();
+	if (nanopi_board[npi_boardtype][0] == '\0') {
+		printf("fail to get boardtype\n");
+		hang();
+	}
+	sprintf(buf, "allwinner/sun50i-h5-%s.dtb", nanopi_board[npi_boardtype]);
+	if (env_set("fdtfile", buf)) {
+		printf("fail to envset fdtfile\n");
+		hang();
+	}
+	printf("BOARD: %s\n", nanopi_board[npi_boardtype]);
+#endif
 }
 #endif
 
diff --git a/configs/nanopi_neo2_black_defconfig b/configs/nanopi_neo2_black_defconfig
index 5548e76e..2919a9b1 100644
--- a/configs/nanopi_neo2_black_defconfig
+++ b/configs/nanopi_neo2_black_defconfig
@@ -1,23 +1,29 @@
 CONFIG_ARM=y
 CONFIG_ARCH_SUNXI=y
-CONFIG_SYS_TEXT_BASE=0x4a000000
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL=y
 CONFIG_MACH_SUN50I_H5=y
 CONFIG_DRAM_CLK=504
 CONFIG_DRAM_ZQ=3881977
-CONFIG_MACPWR="PD6"
 CONFIG_DRAM_ODT_EN=y
+CONFIG_MACPWR="PD6"
 CONFIG_MMC_SUNXI_SLOT_EXTRA=2
+CONFIG_SPL_SPI_SUNXI=y
 CONFIG_DEFAULT_DEVICE_TREE="sun50i-h5-nanopi-neo2-black"
+CONFIG_LOCALVERSION="-armbian"
+# CONFIG_LOCALVERSION_AUTO is not set
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
-CONFIG_SPL=y
-# CONFIG_CMD_IMLS is not set
+CONFIG_BOOTDELAY=1
 # CONFIG_CMD_FLASH is not set
-# CONFIG_CMD_FPGA is not set
 # CONFIG_SPL_DOS_PARTITION is not set
-# CONFIG_SPL_ISO_PARTITION is not set
 # CONFIG_SPL_EFI_PARTITION is not set
-CONFIG_SPL_SPI_SUNXI=y
+CONFIG_BOOT_PROCESS_MULTI_DTB=y
+# CONFIG_ENV_IS_NOWHERE is not set
+# CONFIG_ENV_IS_IN_FAT is not set
+CONFIG_ENV_IS_IN_EXT4=y
+CONFIG_ENV_EXT4_INTERFACE="mmc"
+CONFIG_ENV_EXT4_DEVICE_AND_PART="0:auto"
+CONFIG_ENV_EXT4_FILE="/boot/boot.env"
 CONFIG_SUN8I_EMAC=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_SYS_USB_EVENT_POLL_VIA_INT_QUEUE=y
diff --git a/include/friendlyelec/boardtype.h b/include/friendlyelec/boardtype.h
new file mode 100644
index 00000000..194fbe31
--- /dev/null
+++ b/include/friendlyelec/boardtype.h
@@ -0,0 +1,61 @@
+#ifndef _NANOPI_BOARDTYPE_H
+#define _NANOPI_BOARDTYPE_H
+
+#define CONFIG_MACH_SUN50I_H5_NANOPI
+
+#if defined(CONFIG_MACH_SUN8I_H3_NANOPI) || defined(CONFIG_MACH_SUN50I_H5_NANOPI)
+#define CPU_TYPE_H2_1    (0x42)
+#define CPU_TYPE_H2_2    (0x83)
+#define CPU_TYPE_H3_1    (0x00)
+#define CPU_TYPE_H3_2    (0x81)
+#define CPU_TYPE_H3D     (0x58)
+#define CPU_TYPE_H5      (0x01)            // H5-CPUID=0x01? NOT reliable
+
+#define BOARD_NAME_LENGTH                 (32)
+
+#define BOARD_TYPE_H3_VARIANT0            (0) // = M1
+#define BOARD_TYPE_H3_VARIANT1            (1) // = NEO
+#define BOARD_TYPE_H3_VARIANT2            (2) // = NEO-AIR
+#define BOARD_TYPE_H3_VARIANT3            (3) // = M1-PLUS
+
+#define BOARD_TYPE_NANOPI_M1              (0)
+#define BOARD_TYPE_NANOPI_NEO             (1)
+#define BOARD_TYPE_NANOPI_NEO_AIR         (2)
+#define BOARD_TYPE_NANOPI_M1_PLUS         (3)
+#define BOARD_TYPE_NANOPI_DUO             (4)
+#define BOARD_TYPE_NANOPI_NEO_CORE        (5)
+#define BOARD_TYPE_NANOPI_K1              (6)
+#define BOARD_TYPE_NANOPI_HERO            (7)
+#define BOARD_TYPE_NANOPI_DUO2            (8)
+#define BOARD_TYPE_NANOPI_R1              (9)
+#define BOARD_TYPE_NANOPI_NEO_S           (10)
+#define BOARD_TYPE_ZEROPI                 (11)
+#define BOARD_TYPE_NANOPI_R1S_H3          (12)
+
+
+#define BOARD_TYPE_H5_VARIANT0            (0) // = NEO-CORE2
+#define BOARD_TYPE_H5_VARIANT1            (1) // = NEO2
+#define BOARD_TYPE_H5_VARIANT2            (2) // = NEO-PLUS2
+#define BOARD_TYPE_H5_VARIANT3            (3) // = M1-PLUS2
+
+#define BOARD_TYPE_NANOPI_NEO_CORE2       (0)       // 00
+#define BOARD_TYPE_NANOPI_NEO2            (1)       // 01
+#define BOARD_TYPE_NANOPI_NEO_PLUS2       (2)       // 10
+#define BOARD_TYPE_NANOPI_M1_PLUS2        (3)       // 11
+#define BOARD_TYPE_NANOPI_K1_PLUS         (4)       // 11-(PG12=0)
+#define BOARD_TYPE_NANOPI_NEO2_V11        (5)       // 01-(PL3=0)
+#define BOARD_TYPE_NANOPI_NEO2_BLACK      (6)
+#define BOARD_TYPE_NANOPI_R1S_H5          (7)
+
+#if defined(CONFIG_MACH_SUN8I_H3_NANOPI)
+#define BOARD_TYPE_MAX                    (BOARD_TYPE_NANOPI_R1S_H3+1)
+#elif defined(CONFIG_MACH_SUN50I_H5_NANOPI)
+#define BOARD_TYPE_MAX                    (BOARD_TYPE_NANOPI_R1S_H5+1)
+#endif
+
+
+int nanopi_get_board(void);
+extern char nanopi_board[][32];
+#endif
+
+#endif
-- 
2.23.0

